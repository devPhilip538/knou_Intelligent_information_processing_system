clc; clear                     % 초기화load HW5_Q2_1_result X1 X2 X3 X T; % 문제 2-1 결과 X Y의 클래스별 분류 및 라벨 데이터 가져오기N = size(X, 1);                % 데이터의 수INP = 2;                       % 입력 뉴런의 수 = 2HID = 5;                       % 은닉 뉴런의 수 = 5OUT = 3;                       % 출력 뉴런의 수 = 3w = rand(INP, HID)*0.4 - 0.2;  % 입력 -> 은닉 뉴런 가중치 초기화w0 = rand(1, HID)*0.4 - 0.2;   % 은닉뉴런에 대한 바이어스 입력에 대한 가중치v = rand(HID, OUT)*0.4 - 0.2;  % 은닉 -> 출력 뉴런 가중치 초기화v0 = rand(1, OUT)*0.4 - 0.2;   % 출력뉴런에 대한 바이어스 입력에 대한 가중치 eta = 0.001;                   % 학습률 = 0.001Mstep = 1000;                  % 최대 반복횟수 = 1000Elimit = 0.05;                 % 오차 한계값, 평균제곱오차 = 0.05 이하for j = 2:Mstep                % 최대 반복횟수까지 수행    for i = 1:N                % 입력(학습)데이터 만큼 반복        x = X(i,:);            % i번째 테스트 데이터를 x에 입력        t = T(i,:);            % i번째 테스트 데이터의 라벨을 t에 입력        uh = x*w + w0;         % 은닉 뉴런의 가중합 계산        z = tanh(uh);          % 은닉노드의 출력값         uo = z*v + v0;         % 출력노드의 가중 합        y = tanh(uo);          % 출력 뉴런 값. 활성화함수로 tanh 사용        e = y - t;             % 목표출력과 출력값의 차이 계산(오차)        E(i,1) = e*e';         % 오차값의 제곱을 수행(평균 제곱오차)        delta_v = d_tanh(y).*e;               % 학습을 위한 출력뉴런의 델타값(기울기) 계산        delta_w = d_tanh(z).*(delta_v*v');    % 학습을 위한 은닉뉴런의 델타값(기울기) 계산        v = v - eta*(z'*delta_v);             % 출력뉴런의 가중치 수정        v0 = v0 - eta*(1*delta_v);            % 출력뉴런의 바이어스 가중치 수정        w = w - eta*(x'*delta_w);             % 은닉뉴런의 가중치 수정        w0 = w0 - eta*(1*delta_w);            % 은닉뉴런의 바이어스 가중치 수정    endendplot(X1(:,1), X1(:,2), 'ro');  % X1의 산점도를 그림(빨강 o)hold on;                       % 덮어쓰기plot(X2(:,1), X2(:,2), 'go');  % X2의 산점도를 그림(녹색 o)hold on;                       % 덮어쓰기plot(X3(:,1), X3(:,2), 'bo');  % X3의 산점도를 그림(파랑 o)legend('C1', 'C2', 'C3');      % 범례 표시grid on;[xd, yd] = meshgrid([-1:0.1:7], [-2:0.1:6]);  % 결정경계를 그리기 위한 순서쌍 생성XYd = [xd(:), yd(:)];        % 좌표평면상의 (x, y) 순서쌍에 대한 변수를 생성(XY)axis([-1 7 -2 6]);           % 표시 영역 고정for i=1:size(XYd,1)          % meshgrid로 얻은 순서쌍에 대해 분류, 순서쌍의 수만큼 for문    x = XYd(i,:);            % 테스트할 데이터(순서쌍 하나가 입력 하나임)    uh = x*w + w0;           % 은닉 뉴런의 가중합 계산    z = tanh(uh);            % 은닉노드의 출력값    uo = z*v + v0;           % 출력노드의 가중 합    y = tanh(uo);            % 활성화함수로 tanh 사용        [a, index] = max(y);    Ytst(i,:) = index;end   % 모든 순서쌍에 대한 분류 끝contour(xd, yd, reshape(Ytst, size(xd))); % res 값을 기준으로 하여 (x,y) 평면상에 등고선을 그림    legend('C1', 'C2', 'C3');      % 범례 표시grid on;save HW5_Q2_2_result v v0 w w0 xd yd Ytst XYd; % 결정경계 데이터 저장